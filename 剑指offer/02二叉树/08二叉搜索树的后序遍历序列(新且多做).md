[二叉搜索树的后序遍历序列_牛客题霸_牛客网](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=23289&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D13%26type%3D13)

```java
import java.util.*;
public class Solution {
    public boolean traversal(int[] nums,int begin,int end){
        //如果区间只有一个元素或者没有元素
        if(end<=begin)
            return true;
        //利用后序遍历最后一个一定根节点的性质进递归。在利用二叉搜索树的性质找到比根节点小的部分进行递归
        //首先找到该二叉搜索树的左子树
        int index=begin;
        while(nums[index]<nums[end])
            index++;
        //此时剩下未遍历的部分正常来说就是其右子树，判断是否都比根节点大；
        int right=index;
        while(nums[index]>nums[end])
            index++;
        //如果未遍历到根节点，那么说明右子树中有比根节点小的值，那么他就是不是二叉搜索树
        if(index!=end)
            return false;
        //否则递归遍历左子树和右子树
        boolean flag1=traversal(nums,begin,right-1);
        boolean flag2=traversal(nums,right,end-1);
        return flag1 && flag2;

    }
    public boolean VerifySquenceOfBST(int [] sequence) {
        if(sequence.length==0)
            return false;
        //左闭右闭区间
        return traversal(sequence,0,sequence.length-1);
    }
}
```