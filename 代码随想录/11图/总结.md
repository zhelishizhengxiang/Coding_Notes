
## 图的存储方式

1. **邻接矩阵**：也就是二维数组，**有向图存单向，无向图存双向**，适用于稠密图（点少边多）
2. **邻接表**：更复杂，数组加链表，适合稀疏图，有权值的链表节点需要新建一个edge类来存，具体是按代码如下所示。
```java
	//普通图的邻接表存储方式
	List<List<Integer>> grid=new ArrayList<>(n+1);
	for(int i=0;i<=arraySum;i++){
		grid.add(new LinkedList<Integer>());
	}
	//全部对节点进行减1操作,符合下标访问
	for(int i=0;i<edgeSum;i++){
		int begin=scanner.nextInt();
		int end=scanner.nextInt();
		grid.get(begin).add(end);
	}

	//带权图的邻接表存储方式
	
	//邻接表中的节点
	class Edge{
	    int to;
	    int val;
	    public Edge(int to,int val){
	        this.to=to;
	        this.val=val;
	    }
	}
	List<List<Edge>> graph=new ArrayList<>(n+1);
	for(int i=0;i<=n;i++){
		graph.add(new LinkedList<>());
	}
	while(m-->0){
		int s=scanner.nextInt();
		int t=scanner.nextInt();
		int val=scanner.nextInt();
		graph.get(s).add(new Edge(t,val));
	}
```

## 图的遍历
1. 深度优先搜索dfs：其实就是回溯模板，只不过单层遍历逻辑是遍历得是邻接节点[[01所有可达路径（DFS）]]
2. 广度优先搜索bfs：**用栈或者是队列都行**。**适合于解决两个点之间的最短路径问题**[[09字符串接龙]]
	![[assets/总结/file-20250608215740916.png]]

## 并查集
用处：==并查集常用来解决连通性问题。判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。==

**并查集比深搜或者广搜解决连通性问题性能更好**


**有向图不能使用并查集，因为两个有一条边只能证明两个单项连通，但不代表连通**

模板代码如下所示
```java
int n = 1005; // n根据题目中节点数量而定，一般比节点数量大一点就好
int[] father=new int[n];

// 并查集初始化
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}
// 并查集里寻根的过程
int find(int u) {
	if (u == father[u]) return u;
    else return father[u] = find(father[u]); // 路径压缩

}

// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}

// 将v->u 这条边加入并查集,或者u->v都可以
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}
```

## 题型归类

### DFS和BFS

#### 1.岛屿问题
[[02岛屿数量]]：求岛屿数量（需要使用visited数组重复遍历）
[[03岛屿的最大面积]]：求最大岛屿的面积：使用bfs的话返回值为岛屿面积；dfs就用一个全局变量实时记录岛屿面积（需要使用visited数组重复遍历）
[[04孤岛的总面积]]：此题就不需要visited数组了，因为求找到不靠边的陆地面积，那么我们只要从周边找到陆地然后 通过 dfs或者bfs 将周边靠陆地且相邻的陆地都变成海洋，然后再去重新遍历地图 统计此时还剩下的陆地就可以了。
[[05沉没孤岛]]：此题同样不需要使用visited数组。思路是
步骤一：深搜或者广搜将地图周边的 1 （陆地）全部改成 2 （特殊标记）
步骤二：将水域中间 1 （陆地）全部改成 水域（0）
步骤三：将之前标记的 2 改为 1 （陆地）
[[07建造最大岛屿]]：第一步：一次遍历地图，得出各个岛屿的面积，并做编号记录。可以使用map记录，key为岛屿编号，value为岛屿面积。第二步：再遍历地图，遍历0的方格（因为要将0变成1），并统计该1（由0变成的1）周边岛屿面积，将其相邻面积相加在一起，遍历所有 0 之后，就可以得出 选一个0变成1 之后的最大面积。
[[08岛屿周长]]：不用惯性思维，使用dfs和bfs，而是直接遍历每一个空格，遇到岛屿则计算其上下左右的空格情况。如果该陆地上下左右的空格是有水域，则说明是一条边

* **岛屿问题什么bfs或者dfs都可以，因为存下来的是岛屿和海洋的地图**，bfs是经典回溯模板，dfs是队列实现
* 注意visited数组的作用是标记以及被遍历过，**无向图的遍历需要用的visited数组，而有向图可以不用。使用dfs时如果回溯的结束条件在for循环中，就需要在main中将该节点标记；如果时放在dfs头部，那么就不需要这样。bfs的标记时机为入队列时而不是出队列时**
* 需要返回岛屿面积时，**bfs直接使用返回值返回，因为它不需要递归；dfs使用一个全局变量进行统计，因为需要递归**

#### 2. 其他问题

[[01所有可达路径（DFS）]]：DFS的模板题，用邻接矩阵存下图，然后根据图的邻接节点来进行遍历
[[06水流问题]]：岛屿数量的变式题，从低到高遍历上边界和下边界，都背遍历过的节点就是所求结点
[[09字符串接龙]]：如何连在一起：用26个字母替换当前字符串的每一个字符，在看替换后 是否在 strList里出现过，就可以判断 两个字符串 是否是链接的。最短路径：采用广搜，使用一个map，key存字符串，val旧村遍历到当前字符串的路径。**注意还原字符串**
[[10有向图的完全可达性]]：bfs或者dfs的模板题，只不过因为边较少，使用邻接表存储会更快一点


### 并查集问题
**并查集常用来解决连通性问题。大白话就是当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。**

[[11寻找存在的路径]]：并查集模板题，两个点联通就相当于两点在同一个集合
[[12冗余路径1]]：并查集模板题，如果两个点在同一集合，那么当前的边就是冗余边
[[13冗余路径2]]: 比1来说，从无向图变成了有向图，从而更加复杂，演化出来了三种情况。


### 最小生成树问题
[[14最小生成树之prim]]
[[15最小生成树之kruskal]]

最小生成树是所有节点的最小连通子图，即：以最小的成本（边的权值）将图中所有节点链接到一起。  


对于最生成树算法有prim算法和kruskal算法，具体如下：  
1. **prim算法是从节点的角度**采用贪心的策略每次寻找距离最小生成树最近的节点并加入到最小生成树中。**minDist数组用来记录每一个节点距离最小生成树的最近距离**，**图用邻接矩阵存**
	* prim三部曲
		1. 第一步，选距离生成树最近节点
		2. 第二步，最近节点加入生成树
		3. 第三步，更新非生成树节点到生成树的距离（即更新minDist数组)
2. **kruskal算法是从节点的角度**采用贪心的策略选择权值最小的边加入到最小生成树中。**所以不用存图，直接存储边的集合，list或者数组都可以，对于如何判断是否在同一个集合，使用并查集即可**实现思路如下：
	* 按照边的权值对边的集合排序，因为要优先选最小的边加入到生成树里
	* 遍历排序后的边  
	    - 如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环
	    - 如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合

应用场景：prim适合稠密图，因为是从节点的角度考虑；kruskal适合稀疏图



### 拓扑排序
[[16拓扑排序]]

意思就是：**给出一个有向无环图，把这个有向图转成线性的排序 就叫拓扑排序**

接下来我给出 拓扑排序的过程，其实就两步：
1. 找到入度为0 的节点，加入结果集
2. 将该节点从图中移除

具体实现：  
* 需要用邻接表来存图结构，之后使用队列来存入读为0的节点。
* 如何把这个入度为0的节点和对应的边从图中移除：要把 该节点作为出发点所连接的节点的 入度 减一。


### 最短路径问题
[[17朴素dijkstra算法]]
[[18djikstra堆优化版]]
[[19bellman_ford算法]]
[[20SPFA(bellman_ford队列优化版)]]
[[21bellman_ford算法之判断负权回路]]
[[22bellman_ford算法之单源有限最短路]]
[[23floyd算法]]
几个最短路径算法的区别：
1. **bellman_ford算法和迪杰斯特拉算法都是单源最短路径，不过迪杰斯特拉不允许边的权值为负数，bellman_ford算法允许边的权值为负数**。二者bellman_ford和dijkstra一样都是可以同时计算出起点 到达 所有节点的最短距离，并不只是终点
2. **Floyd 算法求得是多源最短路径，对边的权值正负没有要求，都可以处理，但不能有负权回路**


这些算法的详细实现如下：
1. dijkstra算法：单源最短路径：在有向有权图中求从起点到其他节点的最短路径算法。**要求权值不能为负**。
	* 朴素dijstra算法：与prim算法高度相似，区别就在于更新mindist数组的算法。**minDist数组 用来记录 每一个节点距离源点的最小距离**。三部曲：
		 1.  第一步，选源点到哪个节点近且该节点未被访问过
		2. 第二步，该最近节点被标记访问过
		3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）
	* dijstra算法堆优化版：依旧是这三部曲，不过需要定义一个edge，存节点和权值，因为普通邻接表没办法存权值，所以用一个class edge去存节点和权值；还需要class pair去存当前节点以及距离源点的最小距离，因为最小堆是根据这个最小距离进行排序。
		* 并且对于第一步的实现是如下的：**在堆优化版本是是利用一个小顶堆，根据节点离源点的最短距离排序，那么每次从堆顶取出来的边就是最小边**

	朴素迪杰斯特拉是从节点的角度去考虑，而堆优化版是从边的角度去考虑

2. **朴素bellman_ford算法：求单源最短路径，允许有负权边，但不允许有负权回路**。直接使用存储每条边，然后每条边做n-1次松弛操作即可

	![[assets/总结/file-20250616202842535.png]]

3. SPFA算法：实际上就是bellman_ford的队列优化版： Bellman_ford 算法 每次都是对所有边进行松弛，其实是多做了一些无用功。**只需要对 上一次松弛的时候更新过的节点作为出发节点所连接的边 进行松弛就够了。所以就可以使用队列来进行实现，队列中装的是上次松弛更新过的节点。**
![[assets/20SPFA(bellman_ford队列优化版)/file-20250617174733945.png]]

4. bellman_ford判断负权回路：在 bellman_ford 算法中，松弛 n-1 次所有的边 就可以求得 起点到任何节点的最短路径，松弛 n 次以上，minDist数组（记录起到到其他节点的最短距离）中的结果也不会有改变。  
	而本题有负权回路的情况下，一直都会有更短的最短路，所以 松弛 第n次，minDist数组 也会发生改变。（**只需绕负权回路若干次就可以一直改变最短路径的值**）

	**思路：那么解决本题的 核心思路，就是在朴素bellman_ford算法的基础上，再多松弛一次，看minDist数组 是否发生变化。**

5. bellman_ford单源有限路径：
	![[assets/22bellman_ford算法之单源有限最短路/file-20250617210904914.png]]
	* **由上图可知，bellman_ford 标准写法是松弛 n-1 次，本题就松弛 k + 1次就好。**
	* 并且由于题目输入边的顺序的不确定性，可能松弛第一次的过程不仅与起点一条边相连的节点更新了，所有节点都更新了。
	* **所以为了让至少经过k个节点的条件能够限制住，所以在每次计算 minDist 时候，要基于 对所有边上一次松弛的 minDist 数值才行，所以我们要记录上一次松弛的minDist**，也就是下图的意思

		![[assets/22bellman_ford算法之单源有限最短路/file-20250617214604463.png]]



基于bellman_ford算法的各个区别如下图所示，本题指的是单源有限路径的题
![[assets/总结/file-20250617214739606.png]]


**总结bellman_ford算法的几个问题解法：朴素bellman_ford直接用列表存各个边，然后每条边做n-1次松弛操作；队列优化版只需要对 上一次松弛的时候更新过的节点作为出发节点所连接的边 进行松弛就够了。所以就可以使用队列来进行实现，队列中装的是上次松弛更新过的节点；判断有无负权回路只需要松弛第n次看mindist数组是否会变小；求单源有限路径，只需要松弛k+1次，并且要根据上一次的minDist求这次**

总结四道bellman_ford题的**应用场景**：**所有bellman_ford都支持负权值边，而朴素bellman_ford要求不能有负权回路，如果需要在由负权回路的图当中求单源首限路径，那么需要根据并且要根据上一次的minDist求这次的mindist数组

6. floyd算法：本质上是动态规划，详情见[[23floyd算法]]


几个算法求最短路径得使用场景对应如下(并且几种求最短路径得都是带权图):
![[assets/总结/file-20250618150950891.png]]
![[assets/总结/file-20250618150933091.png]]


7. **Astar 是一种广搜的改良版。Astar 关键在于 启发式函数引导我们遍历遍历得方向是朝着重点方向遍历，即影响广搜中从队列中弹出得顺序**，这是影响BFS搜索方向的关键。这样的话就需要将原来广搜得队列该成优先级队列。
	
	对队列里节点进行排序，就需要给每一个节点权值，如何计算权值呢？
	
	**每个节点的权值为F，给出公式为：F = G + H
	G：已经走过的距离，而不是起点距离当前遍历节点得距离
	H：目前遍历的节点到达终点的距离