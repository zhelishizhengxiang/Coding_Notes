所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的
## 动态规划五部曲
**对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！**
1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化：**如果不能直接通过题意找出初始化的值，或者定义的初始状态本身就是非法的状态，那么通过带入特值到递推公式中，看需要初始化为多少。而不是去死扣定义或者是想当然**
4. 确定遍历顺序
5. 举例推导dp数组

**动态规划如何debug**：**找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！**


## 题型分布
![[assets/总结/file-20250508230828644.png]]
![[assets/总结/file-20250508230844508.png]]

### 01背包问题
[[09分割等和子集]]
[[10最后一块石头的重量2]]
[[11目标和（多做）]]
[[12一和零]]


遍历顺序：
* **一维dp数组的背包在遍历顺序上和二维dp数组实现的01背包其实是有很大差异的，大家需要注意！**
* **二维01背包先遍历物品后遍历背包与先便利背包与后遍历物品都可以，但一维背包只能先遍历物品再遍历背包**
* 使用时**默认先遍历物品再遍历背包。二维背包遍历背包时用正序，一维背包遍历时用倒序**

dp含义以及对应的解题方法：  
![[assets/总结/file-20250510175346614.png]]
* 更正0和1是求尽量装满背包的情况下，最多能装多少个物品

***
### 完全背包问题
[[14零钱兑换2]]：求装满背包有多少种组合数
[[15组合总和4]]：求装满背包有多少种排列方式
[[16爬楼梯进阶版]]：求装满背包有多少种排列方式，只不过相当于物品从1开始
[[17零钱兑换]]：求装满背包所需物品得最少个数，注意越界问题
[[18完全平方数]]：求装满背包所需物品得最少个数，注意越界问题
[[19单词拆分]]：排列数，并且为**字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词**

遍历顺序：
* **二维dp数组既可以先遍历背包后遍历物品，也可以先便利物品，后遍历背包**
* **一维数组同样两种方式都可以**
* **但是对于dp数组含义为装满背包有多少方法时，情况就不一样了**

具体为：  
* **如果求组合数就是外层for循环遍历物品，内层for遍历背包**
* **如果求排列数就是外层for遍历背包，内层for循环遍历物品**

具体得理解过程如下图所示：  
![[assets/总结/file-20250519214259514.png]]


![[assets/总结/file-20250519214120727.png]]


### 打家劫舍问题
[[20打家劫舍]]：递推公式：如果要偷该家，那么只要投i-2家，i-1家不能投；如果没有偷该家，没那么就可以偷i-1家
[[21打家劫舍2]]：环形数组问题不好直接解决，可以分成：只考虑头结点；只考虑尾节点、尾结点和首节点都不考虑（包含在前两种情况之中）
[[22打家劫舍3]]：树型dp，每个节点都有两个状态：偷与不投情况下获得的最高金额

### 买卖股票的最佳时机问题
![[assets/总结/file-20250522213031696.png]]

股票买卖系列部分题目可以用贪心算法解出来，但是只能接出来特定题目，而动态规划时一整套专门的思路，所以此处只讲动态规划

都是询问能够获得的最大收益，你但是选择条件不同：  
[[23买卖股票的最佳时机]]：股票只能买卖1次
[[24买卖股票的最佳时机2]]：股票可以买卖多次
[[25买卖股票的最佳时机3]]：股票只能至多买卖2次
[[26买卖股票的最佳时机4]]：股票至多买卖k次
[[27买卖股票的最佳时机含冷冻期]]：可以买卖多次但是每次卖出有冷冻期1天
[[28买卖股票的最佳时机含手续费]]：可以多次买卖，但每次具有手续费

股票问题方法论：  
1. 由于每天股票的价格是变化的，可以选择买与不买，所以一维dp数组是没有办法将状态全是表示全的
2. 基于上点，股票问题的dp含义为二维数组dp\[i]\[j]表示第i天的某一个状态所能得到的最多现金，那么根据股票可以买卖的次数可以得到以下dp含义：  
	* **只能买卖一次和多次都是两个状态，dp\[i]\[0] 表示第i天持有股票所得现金。dp\[i]\[1] 表示第i天不持有股票所得现金。**
	* **只能卖买两次和k次都是2k加1个状态， 0 表示不操作、1 第一次持有、2 第一次不持有、3 第二次持有、4 第二次不持有.....除了0以外，偶数就是不持有，奇数就是持有**。
	* 那么得到的递推公式都是基于下面的递推公式得到  
	![[assets/总结/file-20250522213717671.png]]
3. 对于具有冷冻期的题，由于之前的dp含义中不持有股票包括当天卖出股票和持续前一天不持有卖出股票的状态，对于冷冻期来说不知道他前一天是刚刚卖出还是持续不持有，所以必须把这两个状态分开来写，那么就会有以下四个状态：  
	![[assets/总结/file-20250522214143143.png]]
	
	所以递推公式也会有多种情况如下图所示：  
	![[assets/总结/file-20250522214247709.png]]

4. 含手续费问题只需要在计算卖出操作的时候减去手续费就可以了，代码几乎是一样的。
5. 返回值的情况，除了含冷冻期问题需要将不持有股票的三种状态取最大值返回之外，其他提都只需要返回最后一天不持有股票的状态即可。解释如下：

	![[assets/总结/file-20250522214533874.png]]

### 子序列问题

==注意：子序列问题如果时在两个数组或者字符串之间的，那么必须是二维dp数组，
并且的dp定义是0-i-1而不是0-i，这样dp数组不用初始化或者说初始化十分简单==

==注意定义：如果dp含义是以i-1为结尾这种的，那么是求当前dp时必须要包含该元素情况下的dp，而不是只将他纳入考虑范围[[29最长递增子序列（不连续）]]；如果时0-i这种的，那么只是讲当前元素纳为考虑范围==
#### 1.不连续子序列问题
[[29最长递增子序列（不连续）]]：求最长递增子序列长度：位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。
[[32最长公共子序列（不连续）]]求最长公共子序列的长度：两个元素相同的情况，以及不相同的情况
[[33不相交的线]]：同[[32最长公共子序列（不连续）]]

#### 2.连续子序列问题
[[30最长连续递增子序列]]:只需要与前一个元素比较是否递增即可
[[31最长重复子数组（连续）]]：两个当前元素如果想等那么在之前基础上加1，如果不是，那么就为0，因为dp含义是以当前两个元素结尾的重复子数组长度
[[34最大子数组和]]：要么延续前面的连续子数组，要么该值连续子数组的头

#### 3.编辑距离问题
[[35判断子序列]]  
![[assets/总结/file-20250529222630966.png]]

[[36不同的子序列]]  
![[assets/总结/file-20250529222709917.png]]
[[37两个字符串的删除操作]]  
![[assets/总结/file-20250529222736500.png]]
[[38编辑距离]]  

![[assets/总结/file-20250529222756498.png]]


1. **dp数组统一定义为：下标为0-i-1和下标为0-j-1的最长公共子序列的长度，或者要求的最小操作次数**
2. **都是考虑两种情况，相等如何，不相等如何。**

#### 4.回文串问题
[[39回文子串]]
[[40最长回文子序列（非连续）]]

1. **回文串问题都是二维dp数组，并且代表回文串的开始和结束，左闭右闭区间。并且遍历顺序都是从下到上，从坐到右，递推公式一定都是由下面图推出来的**  
	![[assets/总结/file-20250529231803603.png]]
2. **问连续的回文子串时，直接用变量记录题目要求的结果，然后dp为`boolean`型的。要是不连续，那么就为int型，记录当前串中的长度**

